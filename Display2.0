import pandas as pd
import tkinter as tk
from tkinter import font, messagebox
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import os
import time
from datetime import datetime
from PIL import Image, ImageTk, ImageGrab # ImageGrab para screenshots
import random
import sqlite3
import re
import schedule # Para agendamento
import threading # Para rodar o envio de email em paralelo
import win32com.client as win32 # Para controlar o Outlook
import pythoncom

# =============================================================================
# 1. CONFIGURA√á√ÉO CENTRALIZADA
# =============================================================================
CONFIG = {
    "file_paths": {
        "excel": "Planilha_Pontuacao_Atualizada.xlsx",
        "clients": "Tabela_Cliente.xlsx",
        "icons_folder": "icons",
        "screenshots_folder": "screenshots_temp" # Pasta tempor√°ria para fotos
    },
    "window": {
        "title": "Dashboard de Performance - RODOLUB v2.0 (Email Auto)",
        "geometry": "1366x768"
    },
    "email_settings": {
        "send_time": "15:00", # Hor√°rio de envio (formato HH:MM)
        "boss_email": "nathalia@rodolub.com.br", # <--- COLOQUE O EMAIL DA CHEFE AQUI
        "coordinator_emails": {
            # --- IMPORTANTE: Coloque aqui o nome EXATO do coordenador (como est√° na A3) e seu email ---
            "EDDIE ALVES LOBATO": "email_coord@exemplo.com",
            "LUIZ HENRIQUE SEGGUES RODRIGUES": "email_coord@exemplo.com",
            "MAURICIO DA CONCEI√á√ÉO CARNEIRO": "email_coord@exemplo.com",
            "MAURICIO GUEDES STREIT": "email_coord@exemplo.com",
            "PATRICK SOARES FERREIRA PITHON FERNANDES": "email_coord@exemplo.com",
            #"Coordenador 3": "email_coord3@exemplo.com", # Exemplo
            # Adicione todos os coordenadores
        },
        "subject": "Atualiza√ß√£o Campanha Execu√ß√£o Premiada",
        "body_header": "Boa tarde!\n\nSegue(m) atualizada(s) a(s) foto(s) da campanha Execu√ß√£o Premiada.",
        "body_footer": "\n\nAviso: Os dados s√£o atualizados de Segunda a Sexta, das 09:00 √†s 15:00. Pontua√ß√µes enviadas ap√≥s este hor√°rio ser√£o processadas no pr√≥ximo dia √∫til."
    },
    "scoring_actions": {
        "Planograma": 3, "Precificador": 2, "MPDV": 1,
        "Ponto extra com produto foco": 5, "Troca Inteligente": 2, "Ativa√ß√£o": 1
    },
    "colors": {
        "background": "#1c1c24", "sidebar_bg": "#252836", "content_bg": "#1f1d2b",
        "primary": "#00ff99", "secondary": "#ffc700", "text_light": "#ffffff",
        "text_dark": "#8e8e93", "button_hover": "#3a3d4a",
        "chart_colors": ["#00ff99", "#ffc700", "#00c2ff", "#ff5733", "#c700ff"]
    },
    "fonts": {
        "title": ("Segoe UI", 32, "bold"), "subtitle": ("Segoe UI", 24, "bold"),
        "normal_bold": ("Segoe UI", 16, "bold"), "normal": ("Segoe UI", 16),
        "monospace": ("Consolas", 18, "bold"), "display": ("Segoe UI Black", 90, "bold")
    },
    "animation": { "reveal_speed_ms": 20, "ranking_slide_delay_ms": 100, "chart_draw_speed_ms": 5 },
    "update_interval_ms": 2000,
    "slideshow_interval_seconds": 20,
    "coordinator_slideshow_seconds": 8
}

# =============================================================================
# 2. CLASSE DE GERENCIAMENTO DE DADOS (COM DADOS DE COORDENADOR)
# =============================================================================

class DataHandler:
    # ... (A classe DataHandler inteira da vers√£o anterior permanece aqui) ...
    # (Incluindo __init__, _setup_database, _save_event_to_db, add_score_event_to_history,
    # _load_client_data, get_client_info, add_score, _save_scores_to_db, load_and_process_data,
    # _calculate_all_metrics, _calculate_achievements, get_data, get_line_chart_data)

    def __init__(self, file_path_scores, file_path_clients):
        self.file_path_scores = file_path_scores
        self.file_path_clients = file_path_clients
        self.db_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "dashboard_history.db")
        self.df, self.df_previous, self.df_clients = pd.DataFrame(), pd.DataFrame(), pd.DataFrame()
        self.data, self.history = {}, []
        self.update_flag = True
        self._setup_database()
        self._load_client_data()

    def _setup_database(self):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute('CREATE TABLE IF NOT EXISTS leadership_history (id INTEGER PRIMARY KEY, timestamp TEXT, event_type TEXT, event_text TEXT, points REAL, details TEXT)')
        cursor.execute('CREATE TABLE IF NOT EXISTS score_history (id INTEGER PRIMARY KEY, timestamp TEXT, vendedor TEXT, pontos REAL)')
        conn.commit()
        cursor.execute("PRAGMA table_info(leadership_history)")
        columns = [info[1] for info in cursor.fetchall()]
        if 'details' not in columns: cursor.execute("ALTER TABLE leadership_history ADD COLUMN details TEXT"); conn.commit()
        cursor.execute("SELECT timestamp, event_type, event_text, points, details FROM leadership_history ORDER BY timestamp DESC")
        for row in cursor.fetchall(): self.history.append({"timestamp": datetime.fromisoformat(row[0]), "type": row[1], "text": row[2], "points": row[3], "details": row[4]})
        conn.close()

    def _save_event_to_db(self, event):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute('INSERT INTO leadership_history (timestamp, event_type, event_text, points, details) VALUES (?, ?, ?, ?, ?)',
                       (event['timestamp'].isoformat(), event['type'], event['text'], event['points'], event.get('details', '')))
        conn.commit()
        conn.close()

    def add_score_event_to_history(self, text, points, details_text=""):
        event = {"timestamp": datetime.now(), "points": points, "type": "score_update", "text": text, "details": details_text}
        self.history.insert(0, event)
        self._save_event_to_db(event)

    def _load_client_data(self):
        try:
            self.df_clients = pd.read_excel(self.file_path_clients, header=0)
            normalized_columns = [re.sub(r'\s+', ' ', col).strip() for col in self.df_clients.columns]
            self.df_clients.columns = normalized_columns
            self.df_clients.rename(columns={"R√≥tulos de Linha": "ID_Cliente", "Nome da conta": "Nome_Cliente", "Vendedor": "Vendedor"}, inplace=True)
            if "ID_Cliente" not in self.df_clients.columns or "Nome_Cliente" not in self.df_clients.columns:
                print("ERRO CR√çTICO: Colunas 'R√≥tulos de Linha' ou 'Nome da conta' n√£o encontradas."); self.df_clients = pd.DataFrame(); return
            self.df_clients['ID_Cliente'] = self.df_clients['ID_Cliente'].astype(str).str.strip()
            self.df_clients.dropna(subset=['ID_Cliente'], inplace=True)
            print(f"Tabela de clientes carregada com {len(self.df_clients)} registros.")
        except Exception as e:
            print(f"ERRO CR√çTICO ao carregar Tabela_Cliente.xlsx: {e}"); self.df_clients = pd.DataFrame()

    def get_client_info(self, client_id):
        if self.df_clients.empty: return None, None
        try:
            search_id = str(client_id).strip()
            client_row = self.df_clients[self.df_clients["ID_Cliente"] == search_id]
            if not client_row.empty: return client_row.iloc[0]["Nome_Cliente"], client_row.iloc[0]["Vendedor"]
        except Exception as e:
            print(f"Erro ao procurar ID do cliente: {e}")
        return None, None

    def add_score(self, vendedor, pontos):
        try:
            from openpyxl import load_workbook
            workbook = load_workbook(self.file_path_scores)
            vendedor_encontrado = False
            for i in range(1, 6):
                sheet_name = f"Plan{i}"
                if sheet_name in workbook.sheetnames:
                    sheet = workbook[sheet_name]
                    for row in range(3, 9): # Assumindo 6 vendedores por planilha (B3 a B8)
                        nome_vendedor_planilha = sheet[f'B{row}'].value
                        if nome_vendedor_planilha and vendedor.strip().lower() == str(nome_vendedor_planilha).strip().lower():
                            pontuacao_atual = sheet[f'C{row}'].value or 0
                            nova_pontuacao = float(pontuacao_atual) + float(pontos)
                            sheet[f'C{row}'].value = nova_pontuacao
                            vendedor_encontrado = True
                            print(f"Vendedor '{vendedor}' encontrado na Plan{i}. Pontua√ß√£o atualizada de {pontuacao_atual} para {nova_pontuacao}.")
                            break
                if vendedor_encontrado: break
            if vendedor_encontrado:
                workbook.save(self.file_path_scores); return True
            else:
                print(f"ERRO: Vendedor '{vendedor}' n√£o foi encontrado."); return False
        except PermissionError:
             print(f"ERRO DE PERMISS√ÉO: N√£o foi poss√≠vel salvar '{self.file_path_scores}'. O arquivo est√° aberto em outro programa (Excel)?")
             return False
        except Exception as e:
            print(f"ERRO ao escrever na planilha: {e}"); return False

    def _save_scores_to_db(self, df_scores):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        timestamp = datetime.now().isoformat()
        for _, row in df_scores.iterrows():
            cursor.execute('INSERT INTO score_history (timestamp, vendedor, pontos) VALUES (?, ?, ?)', (timestamp, row['Vendedor'], row['Pontos']))
        conn.commit()
        conn.close()

    def load_and_process_data(self):
        if not self.update_flag: return False
        try:
            from openpyxl import load_workbook
            time.sleep(0.2)
            all_dfs = []
            workbook = load_workbook(self.file_path_scores, data_only=True)

            for i in range(1, 6):
                sheet_name = f"Plan{i}"
                if sheet_name in workbook.sheetnames:
                    sheet = workbook[sheet_name]
                    coordinator_name = sheet['A3'].value or f"Coordenador {i}"
                    try:
                        df_sheet = pd.read_excel(self.file_path_scores, sheet_name=sheet_name, skiprows=2, usecols="B:C", header=None, names=['Vendedor', 'Pontos'])
                        df_sheet['Coordenador'] = coordinator_name
                        all_dfs.append(df_sheet)
                    except Exception as e: continue

            if not all_dfs: self.update_flag = False; return False
            new_df = pd.concat(all_dfs, ignore_index=True)
            new_df["Pontos"] = pd.to_numeric(new_df["Pontos"], errors="coerce")
            new_df = new_df.dropna(subset=["Vendedor", "Pontos"])
            new_df = new_df.sort_values(by="Pontos", ascending=False, ignore_index=True)

            # Compara apenas as colunas relevantes para salvar no hist√≥rico de score
            cols_to_compare = ['Vendedor', 'Pontos']
            df_for_compare = self.df[cols_to_compare] if not self.df.empty and all(c in self.df.columns for c in cols_to_compare) else pd.DataFrame(columns=cols_to_compare)
            if not new_df[cols_to_compare].equals(df_for_compare):
                 self._save_scores_to_db(new_df)

            self.df_previous = self.df.copy()
            self.df = new_df
            self._calculate_all_metrics()
            self.update_flag = False
            return True
        except Exception as e:
            print(f"Erro ao carregar dados de pontua√ß√£o: {e}"); self.update_flag = False; return False

    def _calculate_all_metrics(self):
        if self.df.empty:
            self.data = {"leader": None, "tie": None, "top_5": [], "achievements": [], "history": self.history, "coordinator_rankings": {}}; return

        coordinator_rankings = {}
        if 'Coordenador' in self.df.columns:
            for name, group in self.df.groupby('Coordenador'):
                sorted_group = group.sort_values(by='Pontos', ascending=False)
                coordinator_rankings[name] = sorted_group.to_dict('records')

        old_leader_name = self.df_previous.iloc[0]['Vendedor'] if not self.df_previous.empty and 'Vendedor' in self.df_previous.columns else None
        new_leader_name = self.df.iloc[0]['Vendedor'] if not self.df.empty else None

        if old_leader_name and new_leader_name and old_leader_name != new_leader_name:
            event = {"timestamp": datetime.now(), "points": self.df.iloc[0]['Pontos'], "type": "takeover", "text": f"{new_leader_name} tomou a lideran√ßa de {old_leader_name}!"}
            self.history.insert(0, event); self._save_event_to_db(event)

        leader_score = self.df.iloc[0]['Pontos'] if not self.df.empty else 0
        tied_leaders = self.df[self.df['Pontos'] == leader_score] if not self.df.empty else pd.DataFrame()

        self.data.update({
            'leader': self.df.iloc[0].to_dict() if len(tied_leaders) == 1 else None,
            'tie': tied_leaders.to_dict('records') if len(tied_leaders) > 1 else None,
            'top_5': self.df.head(5).to_dict('records') if not self.df.empty else [],
            'history': self.history,
            'coordinator_rankings': coordinator_rankings
        })
        self._calculate_achievements()

    def _calculate_achievements(self):
        achievements = []
        if self.df.empty: self.data['achievements'] = []; return
        if self.data['leader']: achievements.append({"icon": "üèÜ", "title": "Na Lideran√ßa", "vendedor": self.data['leader']['Vendedor'], "desc": "No topo do placar!"})
        if not self.df_previous.empty and 'Vendedor' in self.df_previous.columns and 'Pontos' in self.df_previous.columns:
             try: # Adiciona try-except para mais robustez
                merged = pd.merge(self.df, self.df_previous, on='Vendedor', suffixes=('_new', '_old'), how='left').fillna(0)
                if 'Pontos_new' in merged.columns and 'Pontos_old' in merged.columns:
                    merged['gain'] = merged['Pontos_new'] - merged['Pontos_old']
                    if not merged.empty and merged['gain'].max() > 0:
                        hottest = merged.loc[merged['gain'].idxmax()]
                        achievements.append({"icon": "üî•", "title": "Em Chamas", "vendedor": hottest['Vendedor'], "desc": f"Ganhou +{int(hottest['gain'])} pontos."})

                df_new_ranked = self.df.reset_index().rename(columns={'index': 'rank_new'})
                df_old_ranked = self.df_previous.reset_index().rename(columns={'index': 'rank_old'})
                merged_rank = pd.merge(df_new_ranked, df_old_ranked, on='Vendedor', how='left').fillna(len(df_old_ranked))
                if not merged_rank.empty and 'rank_old' in merged_rank.columns and 'rank_new' in merged_rank.columns:
                    merged_rank['rank_climb'] = merged_rank['rank_old'] - merged_rank['rank_new']
                    if 'rank_climb' in merged_rank.columns and merged_rank['rank_climb'].max() > 0:
                        climber = merged_rank.loc[merged_rank['rank_climb'].idxmax()]
                        achievements.append({"icon": "üöÄ", "title": "Velocista", "vendedor": climber['Vendedor'], "desc": f"Subiu {int(climber['rank_climb'])} posi√ß√µes."})
             except Exception as e:
                 print(f"Erro ao calcular conquistas: {e}") # Ajuda a depurar
        self.data['achievements'] = achievements


    def get_data(self): return self.data
    def get_line_chart_data(self):
        if self.df.empty: return {}
        top_5_vendedores = self.df.head(5)['Vendedor'].tolist()
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        chart_data = {}
        for vendedor in top_5_vendedores:
            cursor.execute("SELECT timestamp, pontos FROM score_history WHERE vendedor = ? ORDER BY timestamp ASC", (vendedor,))
            chart_data[vendedor] = [(datetime.fromisoformat(row[0]), row[1]) for row in cursor.fetchall()]
        conn.close()
        return chart_data
        
# =============================================================================
# 3. CLASSES DE TELA (Com Coordenadores)
# =============================================================================
class BaseScreen(tk.Frame):
    # ... (c√≥digo inalterado) ...
    def __init__(self, parent, data_handler, **kwargs):
        super().__init__(parent, bg=CONFIG["colors"]["content_bg"], **kwargs)
        self.data_handler = data_handler
        self.animation_job = None
        self.build_ui()
    def build_ui(self):
        self.title_label = tk.Label(self, text="T√≠tulo", font=CONFIG["fonts"]["title"], bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["primary"])
        self.title_label.pack(pady=(20, 10))
    def show(self, single_coord=None): # Modificado para aceitar argumento
        self.pack(fill="both", expand=True)
        if self.animation_job: self.after_cancel(self.animation_job)
        self.update_content(single_coord=single_coord) # Passa o argumento
    def hide(self):
        if self.animation_job: self.after_cancel(self.animation_job)
        self.pack_forget()
    def update_content(self, single_coord=None): pass # Modificado para aceitar argumento

class LeaderScreen(BaseScreen):
    # ... (c√≥digo inalterado) ...
    def build_ui(self):
        self.config(bg=CONFIG["colors"]["content_bg"])
        center_frame = tk.Frame(self, bg=CONFIG["colors"]["content_bg"])
        center_frame.pack(expand=True)
        self.title_label = tk.Label(center_frame, font=CONFIG["fonts"]["title"], bg=CONFIG["colors"]["content_bg"])
        self.title_label.pack(pady=(10, 20), padx=20)
        self.name_label = tk.Label(center_frame, font=CONFIG["fonts"]["display"], bg=CONFIG["colors"]["content_bg"])
        self.name_label.pack(pady=20, padx=50)
        self.points_label = tk.Label(center_frame, font=CONFIG["fonts"]["subtitle"], bg=CONFIG["colors"]["content_bg"])
        self.points_label.pack(pady=20, padx=20)
        self.bind("<Configure>", self._on_resize)
    def _on_resize(self, event=None):
        wraplength = self.winfo_width() - 100
        if wraplength > 0: self.name_label.config(wraplength=wraplength); self.title_label.config(wraplength=wraplength)
    def _animate_reveal(self, label, final_color):
        label.config(fg="#333")
        self.after(100, lambda: label.config(fg="#666"))
        self.after(200, lambda: label.config(fg="#999"))
        self.after(300, lambda: label.config(fg="#ccc"))
        self.after(400, lambda: label.config(fg=final_color))
    def update_content(self, single_coord=None):
        data = self.data_handler.get_data()
        if data.get('leader'):
            leader, name = data['leader'], data['leader']['Vendedor']
            font_size = 90
            if len(name) > 40: font_size = 40
            elif len(name) > 30: font_size = 50
            elif len(name) > 20: font_size = 65
            self.title_label.config(text="L√çDER ATUAL", fg=CONFIG["colors"]["primary"])
            self.name_label.config(text=name, font=("Segoe UI Black", font_size, "bold"))
            self.points_label.config(text=f"{int(leader['Pontos'])} PONTOS")
            self._animate_reveal(self.name_label, CONFIG["colors"]["text_light"])
            self._animate_reveal(self.points_label, CONFIG["colors"]["secondary"])
        elif data.get('tie'):
            names = " & ".join([p['Vendedor'] for p in data['tie']])
            points = int(data['tie'][0]['Pontos'])
            font_size = 24
            if len(names) > 80: font_size = 16
            elif len(names) > 50: font_size = 20
            self.title_label.config(text="EMPATE NA LIDERAN√áA!", fg=CONFIG["colors"]["secondary"])
            self.name_label.config(text=names, font=("Segoe UI", font_size, "bold"))
            self.points_label.config(text=f"{points} PONTOS")
            self._animate_reveal(self.name_label, CONFIG["colors"]["text_light"])
            self._animate_reveal(self.points_label, CONFIG["colors"]["primary"])
        else:
            self.title_label.config(text="")
            self.name_label.config(text="Aguardando Dados...", font=CONFIG["fonts"]["title"], fg=CONFIG["colors"]["text_dark"])
            self.points_label.config(text="")
        self.after(10, self._on_resize)
    def show(self, single_coord=None): super().show(); self.after(50, self._on_resize)

class RankingScreen(BaseScreen):
    # ... (c√≥digo inalterado) ...
    def build_ui(self):
        self.title_label = tk.Label(self, text="TOP 5 - CLASSIFICA√á√ÉO", font=CONFIG["fonts"]["title"], bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["primary"])
        self.title_label.pack(pady=(20, 30))
        self.ranking_frame = tk.Frame(self, bg=CONFIG["colors"]["content_bg"])
        self.ranking_frame.pack(expand=True, fill="both", padx=50)
    def update_content(self, single_coord=None):
        for widget in self.ranking_frame.winfo_children(): widget.destroy()
        top_5 = self.data_handler.get_data().get('top_5', [])
        if not top_5: tk.Label(self.ranking_frame, text="Aguardando Pontua√ß√£o...", font=CONFIG["fonts"]["subtitle"], bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["text_dark"]).pack(); return
        def animate_entry(index):
            if index >= len(top_5): return
            player = top_5[index]; pos, name = f"{index+1}¬∫", player['Vendedor']
            if len(name) > 28: name = name[:25] + "..."
            text = f"{pos:<5}{name:<30}{int(player['Pontos']):>8} pts"
            entry_frame = tk.Frame(self.ranking_frame, bg=CONFIG["colors"]["content_bg"])
            entry_label = tk.Label(entry_frame, text=text, font=CONFIG["fonts"]["monospace"], bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["text_light"])
            entry_label.pack()
            entry_frame.place(relx=-1.0, rely=index * 0.15 + 0.1, anchor="w")
            self.animation_job = self.after(50 + index * 50, lambda ef=entry_frame, i=index: ef.place(relx=0.5, rely=i * 0.15 + 0.1, anchor="center", relwidth=1.0) if ef.winfo_exists() else None)
            self.animation_job = self.after(CONFIG["animation"]["ranking_slide_delay_ms"] + 50, lambda: animate_entry(index + 1))
        animate_entry(0)

class ChartScreen(BaseScreen):
    # ... (c√≥digo inalterado) ...
    def build_ui(self):
        self.title_label = tk.Label(self, text="JORNADA DA PERFORMANCE", font=CONFIG["fonts"]["title"], bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["primary"])
        self.title_label.pack(pady=(20, 10))
        self.canvas = tk.Canvas(self, bg=CONFIG["colors"]["content_bg"], highlightthickness=0)
        self.canvas.pack(fill="both", expand=True)
    def _draw_chart(self):
        if not self.winfo_exists(): return
        self.canvas.delete("all"); chart_data = self.data_handler.get_line_chart_data()
        if not chart_data or len(self.data_handler.df) < 1: self.canvas.create_text(self.winfo_width()/2, self.winfo_height()/2, text="Coletando hist√≥rico...", font=CONFIG["fonts"]["subtitle"], fill=CONFIG["colors"]["text_dark"]); return
        w, h = self.winfo_width(), self.winfo_height()
        if w <= 1 or h <= 1: self.animation_job = self.after(100, self._draw_chart); return
        margin = {'top': 40, 'bottom': 120, 'left': 60, 'right': 60}
        all_points = [p[1] for points_list in chart_data.values() for p in points_list]; all_times = [p[0] for points_list in chart_data.values() for p in points_list]
        min_score, max_score = (min(all_points), max(all_points)) if all_points else (0, 100); max_score = max_score if max_score > min_score else min_score + 1
        min_time, max_time = (min(all_times), max(all_times)) if all_times else (datetime.now(), datetime.now())
        self.canvas.create_line(margin['left'], h - margin['bottom'], w - margin['right'], h - margin['bottom'], fill=CONFIG["colors"]["text_dark"])
        self.canvas.create_line(margin['left'], h - margin['bottom'], margin['left'], margin['top'], fill=CONFIG["colors"]["text_dark"])
        def normalize(score, time):
            time_delta = (max_time - min_time).total_seconds(); score_delta = max_score - min_score
            x = margin['left'] + ((time - min_time).total_seconds() / time_delta) * (w - margin['left'] - margin['right']) if time_delta > 0 else margin['left']
            y = h - margin['bottom'] - ((score - min_score) / score_delta) * (h - margin['top'] - margin['bottom'])
            return int(x), int(y)
        def animate_line(vendedor_data, color):
            points = [normalize(p[1], p[0]) for p in vendedor_data]
            def draw_segment(i):
                if not self.winfo_exists(): return
                if i >= len(points) - 1: return
                self.canvas.create_line(points[i], points[i+1], fill=color, width=3)
                self.animation_job = self.after(CONFIG["animation"]["chart_draw_speed_ms"], lambda: draw_segment(i+1))
            if points: draw_segment(0)
        legend_y = h - margin['bottom'] + 30; legend_item_width = (w - margin['left'] - margin['right']) / len(chart_data) if chart_data else 100
        for i, (vendedor, data) in enumerate(chart_data.items()):
            color = CONFIG["colors"]["chart_colors"][i % len(CONFIG["colors"]["chart_colors"])]
            legend_x_start = margin['left'] + i * legend_item_width; rect_x = legend_x_start + 10; text_x = rect_x + 30
            self.canvas.create_rectangle(rect_x, legend_y, rect_x + 20, legend_y + 20, fill=color, outline="")
            max_text_width = legend_item_width - 50; display_name = vendedor
            if len(vendedor) * 8 > max_text_width: cutoff = int(max_text_width / 8) - 3; display_name = vendedor[:cutoff] + "..." if cutoff > 5 else vendedor
            self.canvas.create_text(text_x, legend_y + 10, text=display_name, anchor="w", fill=CONFIG["colors"]["text_light"], font=CONFIG["fonts"]["normal"])
            if data: animate_line(data, color)
    def update_content(self, single_coord=None):
        if self.animation_job: self.after_cancel(self.animation_job)
        self.animation_job = self.after(100, self._draw_chart)

class CoordinatorScreen(BaseScreen):
     # ... (c√≥digo inalterado) ...
    def build_ui(self):
        self.title_label = tk.Label(self, text="DESEMPENHO POR EQUIPE", font=CONFIG["fonts"]["title"], bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["primary"])
        self.title_label.pack(pady=(20, 10), fill="x")
        self.all_teams_frame = tk.Frame(self, bg=CONFIG["colors"]["content_bg"])
        all_teams_canvas = tk.Canvas(self.all_teams_frame, bg=CONFIG["colors"]["content_bg"], highlightthickness=0)
        all_teams_scrollbar = tk.Scrollbar(self.all_teams_frame, orient="vertical", command=all_teams_canvas.yview)
        self.all_teams_scrollable_frame = tk.Frame(all_teams_canvas, bg=CONFIG["colors"]["content_bg"])
        self.all_teams_scrollable_frame.bind("<Configure>", lambda e: all_teams_canvas.configure(scrollregion=all_teams_canvas.bbox("all")))
        all_teams_canvas.create_window((0, 0), window=self.all_teams_scrollable_frame, anchor="nw")
        all_teams_canvas.configure(yscrollcommand=all_teams_scrollbar.set)
        all_teams_canvas.pack(side="left", fill="both", expand=True)
        all_teams_scrollbar.pack(side="right", fill="y")
        self.single_team_frame = tk.Frame(self, bg=CONFIG["colors"]["content_bg"])
        self.single_team_card = tk.LabelFrame(self.single_team_frame, text="", font=("Segoe UI", 20, "bold"), bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["secondary"], padx=40, pady=20, relief="solid", bd=1)
        self.single_team_card.pack(expand=True)
        all_teams_canvas.bind_all("<MouseWheel>", self._on_mousewheel)
    def _on_mousewheel(self, event):
        if self.all_teams_frame.winfo_ismapped(): canvas = self.all_teams_frame.winfo_children()[0]; canvas.yview_scroll(int(-1*(event.delta/120)), "units")
    def show(self, single_coord=None): self.pack(fill="both", expand=True); self.update_content(single_coord=single_coord)
    def update_content(self, single_coord=None):
        self.all_teams_frame.pack_forget(); self.single_team_frame.pack_forget()
        for widget in self.all_teams_scrollable_frame.winfo_children(): widget.destroy()
        for widget in self.single_team_card.winfo_children(): widget.destroy()
        rankings = self.data_handler.get_data().get('coordinator_rankings', {})
        if not rankings:
            self.single_team_frame.pack(fill="both", expand=True, padx=20, pady=10)
            tk.Label(self.single_team_card, text="Aguardando dados...", font=CONFIG["fonts"]["subtitle"], bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["text_dark"]).pack(expand=True, pady=50)
            return
        if single_coord:
            self.single_team_frame.pack(fill="both", expand=True, padx=20, pady=10)
            if single_coord in rankings:
                salespeople = rankings[single_coord]; self.single_team_card.config(text=f" Equipe: {single_coord} ")
                font_single_team = ("Consolas", 24, "bold")
                for i, seller in enumerate(salespeople):
                    pos, name = f"{i+1}¬∫", seller['Vendedor']; name = name[:22] + "..." if len(name) > 25 else name
                    text = f"{pos:<5}{name:<30}{int(seller['Pontos']):>8} pts"
                    tk.Label(self.single_team_card, text=text, font=font_single_team, bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["text_light"]).pack(anchor="w", pady=3)
                self.single_team_card.lower(); self.after(100, self.single_team_card.lift)
            else: tk.Label(self.single_team_card, text=f"Equipe '{single_coord}' n√£o encontrada.", font=CONFIG["fonts"]["subtitle"], bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["text_dark"]).pack(expand=True, pady=50)
        else:
            self.all_teams_frame.pack(fill="both", expand=True, padx=20, pady=10)
            items_to_display = list(rankings.items())
            def animate_card(index, coord_items):
                if index >= len(coord_items): return
                coord_name, salespeople = coord_items[index]
                card = tk.LabelFrame(self.all_teams_scrollable_frame, text=f" Equipe: {coord_name} ", font=CONFIG["fonts"]["normal_bold"], bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["secondary"], padx=20, pady=10, relief="solid", bd=1)
                card.pack(pady=15, padx=20, fill="x")
                for i, seller in enumerate(salespeople):
                    pos, name = f"{i+1}¬∫", seller['Vendedor']; name = name[:32] + "..." if len(name) > 35 else name
                    text = f"{pos:<5}{name:<40}{int(seller['Pontos']):>8} pts"
                    tk.Label(card, text=text, font=CONFIG["fonts"]["monospace"], bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["text_light"]).pack(anchor="w")
                card.lower(); self.after(50 + index * 50, card.lift)
                if not single_coord: self.animation_job = self.after(150, lambda: animate_card(index + 1, coord_items))
            animate_card(0, items_to_display)

class AchievementsScreen(BaseScreen):
    # ... (c√≥digo inalterado) ...
    def build_ui(self):
        self.title_label = tk.Label(self, text="MURAL DE CONQUISTAS", font=CONFIG["fonts"]["title"], bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["primary"])
        self.title_label.pack(pady=(20, 30))
        self.achievement_frame = tk.Frame(self, bg=CONFIG["colors"]["content_bg"])
        self.achievement_frame.pack(expand=True, fill="both", padx=50)
    def update_content(self, single_coord=None):
        for widget in self.achievement_frame.winfo_children(): widget.destroy()
        achievements = self.data_handler.get_data().get('achievements', [])
        if not achievements: tk.Label(self.achievement_frame, text="Nenhuma conquista.", font=CONFIG["fonts"]["subtitle"], bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["text_dark"]).pack(expand=True); return
        def animate_card(index):
            if index >= len(achievements): return
            ach = achievements[index]
            card = tk.Frame(self.achievement_frame, bg=CONFIG["colors"]["sidebar_bg"], relief="solid", bd=1)
            icon = tk.Label(card, text=ach["icon"], font=("Segoe UI", 30), bg=CONFIG["colors"]["sidebar_bg"], fg=CONFIG["colors"]["secondary"])
            icon.pack(side="left", padx=20, pady=10)
            text_frame = tk.Frame(card, bg=CONFIG["colors"]["sidebar_bg"])
            text_frame.pack(side="left", expand=True, fill="x")
            title = tk.Label(text_frame, text=f"{ach['title']} - {ach['vendedor']}", font=CONFIG["fonts"]["subtitle"], bg=CONFIG["colors"]["sidebar_bg"], fg=CONFIG["colors"]["text_light"], anchor="w")
            title.pack(fill="x")
            desc = tk.Label(text_frame, text=ach["desc"], font=CONFIG["fonts"]["normal"], bg=CONFIG["colors"]["sidebar_bg"], fg=CONFIG["colors"]["text_dark"], anchor="w")
            desc.pack(fill="x")
            card.pack(pady=10, fill="x"); card.lower(); self.after(50 + index * 50, card.lift)
            self.animation_job = self.after(150, lambda: animate_card(index + 1))
        animate_card(0)

class ClockScreen(BaseScreen):
    # ... (c√≥digo inalterado) ...
    def build_ui(self):
        self.clock_job = None
        self.time_label = tk.Label(self, font=("Segoe UI Black", 120, "bold"), bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["text_light"])
        self.time_label.pack(expand=True)
        self.greeting_label = tk.Label(self, font=CONFIG["fonts"]["title"], bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["primary"])
        self.greeting_label.pack(expand=True)
    def update_clock(self):
        now = datetime.now(); self.time_label.config(text=now.strftime("%H:%M:%S"))
        hour = now.hour; greeting = "Boa noite!"; greeting = "Bom dia!" if 5 <= hour < 12 else "Boa tarde!" if 12 <= hour < 18 else greeting
        self.greeting_label.config(text=greeting)
        self.clock_job = self.after(1000, self.update_clock)
    def show(self, single_coord=None): super().show(); self.update_clock()
    def hide(self):
        if self.clock_job: self.after_cancel(self.clock_job); self.clock_job = None
        super().hide()
    def update_content(self, single_coord=None): pass

class ChronicleScreen(BaseScreen):
    # ... (c√≥digo inalterado) ...
    def build_ui(self):
        self.title_label = tk.Label(self, text="CR√îNICA DA LIDERAN√áA", font=CONFIG["fonts"]["title"], bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["primary"])
        self.title_label.pack(pady=(20, 10), fill="x")
        main_frame = tk.Frame(self, bg=CONFIG["colors"]["content_bg"])
        main_frame.pack(fill="both", expand=True, padx=20, pady=10)
        self.canvas = tk.Canvas(main_frame, bg=CONFIG["colors"]["content_bg"], highlightthickness=0)
        scrollbar = tk.Scrollbar(main_frame, orient="vertical", command=self.canvas.yview)
        self.scrollable_frame = tk.Frame(self.canvas, bg=CONFIG["colors"]["content_bg"])
        self.scrollable_frame.bind("<Configure>", self._on_frame_configure)
        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw", tags="frame")
        self.canvas.configure(yscrollcommand=scrollbar.set)
        self.canvas.pack(side="left", fill="both", expand=True)
        # scrollbar.pack(side="right", fill="y") # Removido
        self.bind_all("<MouseWheel>", self._on_mousewheel_stop_scroll)
        self.is_auto_scrolling = False; self.auto_scroll_job = None
    def _on_frame_configure(self, event=None):
        self.canvas.configure(scrollregion=self.canvas.bbox("all")); self.canvas.itemconfig("frame", width=self.canvas.winfo_width())
    def _on_mousewheel_stop_scroll(self, event):
        if self.is_auto_scrolling: self._stop_auto_scroll()
        if self.winfo_ismapped(): self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")
    def _start_auto_scroll(self): self.is_auto_scrolling = True; self._auto_scroll_step()
    def _stop_auto_scroll(self):
        self.is_auto_scrolling = False;
        if self.auto_scroll_job: self.after_cancel(self.auto_scroll_job); self.auto_scroll_job = None
    def _auto_scroll_step(self):
        if not self.is_auto_scrolling or not self.winfo_exists(): return
        current_y_fraction = self.canvas.yview()[1]
        if current_y_fraction < 1.0: self.canvas.yview_scroll(1, "units"); self.auto_scroll_job = self.after(50, self._auto_scroll_step)
        else: self.is_auto_scrolling = False
    def show(self, single_coord=None): super().show(); self.after(1500, self._start_auto_scroll)
    def hide(self): self._stop_auto_scroll(); super().hide()
    def _show_details_popup(self, event_data):
        popup = tk.Toplevel(self); popup.title("Detalhes"); popup.geometry("600x300"); popup.configure(bg=CONFIG["colors"]["sidebar_bg"])
        popup.transient(self.winfo_toplevel()); popup.grab_set()
        tk.Label(popup, text=event_data["text"], font=CONFIG["fonts"]["normal_bold"], wraplength=550, bg=CONFIG["colors"]["sidebar_bg"], fg=CONFIG["colors"]["text_light"], justify="left").pack(pady=20, padx=20)
        tk.Label(popup, text=f"Data: {event_data['timestamp'].strftime('%d/%m/%Y √†s %H:%M:%S')}", font=CONFIG["fonts"]["normal"], bg=CONFIG["colors"]["sidebar_bg"], fg=CONFIG["colors"]["text_dark"]).pack(pady=5, padx=20)
        details_frame = tk.LabelFrame(popup, text=" Detalhes ", font=CONFIG["fonts"]["normal_bold"], bg=CONFIG["colors"]["sidebar_bg"], fg=CONFIG["colors"]["text_light"], padx=10, pady=10)
        details_frame.pack(pady=10, padx=20, fill="x")
        tk.Label(details_frame, text=event_data.get("details", "-"), font=CONFIG["fonts"]["normal"], bg=CONFIG["colors"]["sidebar_bg"], fg=CONFIG["colors"]["secondary"], wraplength=500, justify="left").pack()
        tk.Button(popup, text="Fechar", command=popup.destroy, font=CONFIG["fonts"]["normal_bold"], bg=CONFIG["colors"]["primary"], fg=CONFIG["colors"]["background"], relief="flat").pack(pady=20)
    def update_content(self, single_coord=None):
        for widget in self.scrollable_frame.winfo_children(): widget.destroy()
        history = self.data_handler.get_data().get('history', [])
        self.canvas.yview_moveto(0); self._stop_auto_scroll()
        if not history: tk.Label(self.scrollable_frame, text="Hist√≥ria Vazia...", font=CONFIG["fonts"]["subtitle"], bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["text_dark"]).pack(expand=True, pady=50); return
        icon_map = {"takeover": "üëë", "score_update": "‚≠ê"}
        for event in history:
            outer_frame = tk.Frame(self.scrollable_frame, bg=CONFIG["colors"]["content_bg"]); outer_frame.pack(pady=8, padx=50, fill='x')
            card = tk.Frame(outer_frame, bg=CONFIG["colors"]["sidebar_bg"], relief="solid", bd=1); card.pack()
            icon_label = tk.Label(card, text=icon_map.get(event["type"], "üìú"), font=("Segoe UI", 24), bg=CONFIG["colors"]["sidebar_bg"], fg=CONFIG["colors"]["secondary"])
            icon_label.pack(side="left", padx=15, pady=15)
            text_frame = tk.Frame(card, bg=CONFIG["colors"]["sidebar_bg"]); text_frame.pack(side="left", expand=True, fill="x", pady=10)
            main_label = tk.Label(text_frame, text=event["text"], font=CONFIG["fonts"]["normal_bold"], wraplength=600, bg=CONFIG["colors"]["sidebar_bg"], fg=CONFIG["colors"]["text_light"], anchor="w", justify="left")
            main_label.pack(fill="x")
            sub_text = f"Total: {int(event['points'])} pontos ‚Ä¢ √†s {event['timestamp'].strftime('%H:%M:%S')}"
            sub_label = tk.Label(text_frame, text=sub_text, font=CONFIG["fonts"]["normal"], bg=CONFIG["colors"]["sidebar_bg"], fg=CONFIG["colors"]["text_dark"], anchor="w")
            sub_label.pack(fill="x")
            if event.get("details"):
                card.config(cursor="hand2")
                for widget in [card, icon_label, text_frame, main_label, sub_label]: widget.bind("<Button-1>", lambda e, ev=event: self._show_details_popup(ev))
        self.after(1500, self._start_auto_scroll)


class PontuarScreen(BaseScreen):
    # ... (c√≥digo inalterado) ...
    def build_ui(self):
        self.title_label = tk.Label(self, text="REGISTRAR PONTUA√á√ÉO", font=CONFIG["fonts"]["title"], bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["primary"])
        self.title_label.pack(pady=(20, 15))
        main_frame = tk.Frame(self, bg=CONFIG["colors"]["content_bg"]); main_frame.pack(expand=True)
        entry_frame = tk.Frame(main_frame, bg=CONFIG["colors"]["content_bg"]); entry_frame.pack(pady=10)
        tk.Label(entry_frame, text="Nome Vendedor:", font=CONFIG["fonts"]["normal_bold"], bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["text_light"]).grid(row=0, column=0, sticky="w", padx=10, pady=5)
        self.vendedor_var = tk.StringVar(); self.vendedor_entry = tk.Entry(entry_frame, textvariable=self.vendedor_var, font=CONFIG["fonts"]["normal"], width=40)
        self.vendedor_entry.grid(row=1, column=0, padx=10, pady=5)
        self.autocomplete_listbox = tk.Listbox(entry_frame, font=CONFIG["fonts"]["normal"], width=40)
        self.vendedor_entry.bind("<KeyRelease>", self._on_vendedor_keyup); self.autocomplete_listbox.bind("<<ListboxSelect>>", self._on_vendedor_select)
        tk.Label(entry_frame, text="ID Cliente:", font=CONFIG["fonts"]["normal_bold"], bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["text_light"]).grid(row=0, column=1, sticky="w", padx=10, pady=5)
        self.cliente_id_entry = tk.Entry(entry_frame, font=CONFIG["fonts"]["normal"], width=20); self.cliente_id_entry.grid(row=1, column=1, sticky="w", padx=10, pady=5)
        actions_frame = tk.LabelFrame(main_frame, text=" A√ß√µes ", font=CONFIG["fonts"]["normal_bold"], bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["text_light"], padx=20, pady=10)
        actions_frame.pack(pady=20)
        self.action_vars = {}
        for i, (action, points) in enumerate(CONFIG["scoring_actions"].items()):
            var = tk.IntVar(); chk = tk.Checkbutton(actions_frame, text=f"{action} ({points} pts)", variable=var, font=CONFIG["fonts"]["normal"], bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["text_light"], selectcolor=CONFIG["colors"]["background"], activebackground=CONFIG["colors"]["content_bg"], activeforeground=CONFIG["colors"]["text_light"], command=self._update_total_points)
            chk.grid(row=i, column=0, sticky="w", padx=5, pady=2); self.action_vars[action] = var
        self.total_points_label = tk.Label(main_frame, text="Total: 0 Pontos", font=CONFIG["fonts"]["subtitle"], bg=CONFIG["colors"]["content_bg"], fg=CONFIG["colors"]["secondary"]); self.total_points_label.pack(pady=10)
        submit_button = tk.Button(main_frame, text="Enviar Pontua√ß√£o", font=CONFIG["fonts"]["normal_bold"], bg=CONFIG["colors"]["primary"], fg=CONFIG["colors"]["background"], relief="flat", command=self._submit_score, width=40); submit_button.pack(pady=20)
    def _update_total_points(self): total = sum(CONFIG["scoring_actions"][action] for action, var in self.action_vars.items() if var.get() == 1); self.total_points_label.config(text=f"Total: {total} Pontos")
    def _reset_form(self): self.vendedor_var.set(""); self.cliente_id_entry.delete(0, tk.END); [var.set(0) for var in self.action_vars.values()]; self._update_total_points()
    def _on_vendedor_keyup(self, event):
        typed_text = self.vendedor_var.get().lower(); self.autocomplete_listbox.grid_forget()
        if not typed_text: return
        vendedores = self.data_handler.df_clients["Vendedor"].dropna().unique(); matches = [v for v in vendedores if typed_text in v.lower()]
        self.autocomplete_listbox.delete(0, tk.END)
        if matches: [self.autocomplete_listbox.insert(tk.END, match) for match in matches]; self.autocomplete_listbox.grid(row=2, column=0, sticky="nsew", padx=10)
    def _on_vendedor_select(self, event):
        if not self.autocomplete_listbox.curselection(): return
        self.vendedor_var.set(self.autocomplete_listbox.get(self.autocomplete_listbox.curselection())); self.autocomplete_listbox.grid_forget()
    def _submit_score(self):
        vendedor, cliente_id = self.vendedor_var.get(), self.cliente_id_entry.get()
        if not vendedor or not cliente_id: messagebox.showerror("Erro", "Vendedor e ID Cliente obrigat√≥rios!"); return
        total_points, details_list = 0, []; [(total_points := total_points + CONFIG["scoring_actions"][action], details_list.append(f"{CONFIG['scoring_actions'][action]} pts ({action})")) for action, var in self.action_vars.items() if var.get() == 1]
        if total_points == 0: messagebox.showerror("Erro", "Nenhuma a√ß√£o selecionada!"); return
        nome_cliente, vendedor_associado = self.data_handler.get_client_info(cliente_id)
        if not nome_cliente: messagebox.showerror("Erro", f"ID '{cliente_id}' n√£o encontrado."); return
        if vendedor != vendedor_associado and not messagebox.askyesno("Aviso", f"'{vendedor}' n√£o √© o respons√°vel por '{nome_cliente}' (Resp: {vendedor_associado}).\nContinuar?"): return
        if self.data_handler.add_score(vendedor, total_points):
            details_text = ", ".join(details_list); event_text = f"{vendedor} pontuou {total_points} com {nome_cliente}."
            self.data_handler.add_score_event_to_history(event_text, total_points, details_text)
            messagebox.showinfo("Sucesso", "Pontua√ß√£o registrada!"); self._reset_form()
        else: messagebox.showerror("Erro", f"N√£o foi poss√≠vel salvar.\nVendedor '{vendedor}' encontrado?")

# =============================================================================
# 4. APLICATIVO PRINCIPAL DO DASHBOARD (COM TELA CHEIA E SCREENSHOTS MELHORADOS)
# =============================================================================
# =============================================================================
# 4. APLICATIVO PRINCIPAL DO DASHBOARD (COM TELA CHEIA E SCREENSHOTS MELHORADOS)
# =============================================================================
class DashboardApp:
    def __init__(self, root):
        self.root = root
        self.root.title(CONFIG["window"]["title"])
        self.root.geometry(CONFIG["window"]["geometry"])
        self.root.configure(bg=CONFIG["colors"]["background"])

        scores_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), CONFIG["file_paths"]["excel"])
        clients_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), CONFIG["file_paths"]["clients"])
        self.data_handler = DataHandler(scores_path, clients_path)

        self.file_watcher = self._setup_file_watcher() # Make sure this is defined
        self._create_main_layout() # Make sure this is defined

        self.screens = {
            "leader": LeaderScreen(self.content_frame, self.data_handler),
            "ranking": RankingScreen(self.content_frame, self.data_handler),
            "chart": ChartScreen(self.content_frame, self.data_handler),
            "coordinators": CoordinatorScreen(self.content_frame, self.data_handler),
            "achievements": AchievementsScreen(self.content_frame, self.data_handler),
            "chronicle": ChronicleScreen(self.content_frame, self.data_handler),
            "clock": ClockScreen(self.content_frame, self.data_handler),
            "score": PontuarScreen(self.content_frame, self.data_handler)
        }
        self.current_screen = None

        self.is_presentation_mode = False
        self.slideshow_job = None
        self.slideshow_order = ["leader", "ranking", "coordinators", "chart", "achievements", "chronicle"]
        self.slideshow_index = 0
        self.coordinator_slideshow_index = 0
        self.current_coordinator_list = []

        # Estado da tela cheia
        self.is_fullscreen = False

        self.create_sidebar_buttons()
        self.show_screen("leader")

        self.periodic_update()
        self._setup_scheduler()

    # --- M√âTODO PARA TELA CHEIA ---
    def toggle_fullscreen(self, event=None):
        """Entra ou sai do modo de tela cheia."""
        self.is_fullscreen = not self.is_fullscreen
        self.root.attributes("-fullscreen", self.is_fullscreen)
        print(f"Tela cheia: {'Ligada' if self.is_fullscreen else 'Desligada'}")

    # --- M√©todos de Configura√ß√£o e Layout ---
    def _setup_file_watcher(self):
        """Configura o monitoramento de modifica√ß√µes no arquivo Excel."""
        class ExcelEventHandler(FileSystemEventHandler):
            def __init__(self, data_handler):
                self.data_handler = data_handler
            def on_modified(self, event):
                if event.src_path.endswith(CONFIG["file_paths"]["excel"]):
                    print(f"Modifica√ß√£o detectada em: {event.src_path}")
                    self.data_handler.update_flag = True
            def on_created(self, event):
                if event.src_path.endswith(CONFIG["file_paths"]["excel"]):
                    print(f"Arquivo criado/recriado: {event.src_path}")
                    self.data_handler.update_flag = True
        observer = Observer()
        observer.schedule(ExcelEventHandler(self.data_handler), path=os.path.dirname(os.path.abspath(__file__)), recursive=False)
        observer.start()
        print("Monitoramento de arquivo iniciado.")
        return observer

    def _create_main_layout(self):
        """Cria os frames principais da interface (barra lateral e conte√∫do)."""
        self.sidebar_frame = tk.Frame(self.root, bg=CONFIG["colors"]["sidebar_bg"], width=250)
        self.sidebar_frame.pack(side="left", fill="y")
        self.sidebar_frame.pack_propagate(False) # Impede que o frame encolha

        self.content_frame = tk.Frame(self.root, bg=CONFIG["colors"]["content_bg"])
        self.content_frame.pack(side="right", fill="both", expand=True)

        # T√≠tulo na Sidebar
        tk.Label(self.sidebar_frame, text="RODOLUB", font=CONFIG["fonts"]["title"], bg=CONFIG["colors"]["sidebar_bg"], fg=CONFIG["colors"]["primary"]).pack(pady=20)
        tk.Frame(self.sidebar_frame, height=2, bg=CONFIG["colors"]["primary"]).pack(fill="x", padx=10) # Linha divis√≥ria

    def create_sidebar_buttons(self):
        """Cria todos os bot√µes na barra lateral."""
        buttons = {
            "leader": "L√≠der", "ranking": "Ranking", "coordinators": "Coordenadores", "chart": "Gr√°fico",
            "achievements": "Conquistas", "chronicle": "Cr√¥nica", "clock": "Rel√≥gio", "score": "Pontuar"
        }
        self.nav_buttons = {}
        icon_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), CONFIG["file_paths"]["icons_folder"])

        # Bot√µes de Navega√ß√£o
        for name, text in buttons.items():
            icon = None
            try:
                img = Image.open(os.path.join(icon_path, f"{name}.png")).resize((30, 30), Image.Resampling.LANCZOS)
                icon = ImageTk.PhotoImage(img)
            except Exception: pass # Ignora erro se √≠cone n√£o existe
            btn = tk.Button(self.sidebar_frame, text=f"  {text}", image=icon, compound="left", font=CONFIG["fonts"]["normal_bold"], bg=CONFIG["colors"]["sidebar_bg"], fg=CONFIG["colors"]["text_light"], relief="flat", anchor="w", command=lambda n=name: self.show_screen(n))
            btn.image = icon # Keep reference
            btn.pack(fill="x", pady=5, padx=10)
            self.nav_buttons[name] = btn
            btn.bind("<Enter>", lambda e, b=btn: b.config(bg=CONFIG["colors"]["button_hover"]))
            btn.bind("<Leave>", lambda e, b=btn: b.config(bg=CONFIG["colors"]["sidebar_bg"]))

        # Separador
        tk.Frame(self.sidebar_frame, height=2, bg=CONFIG["colors"]["button_hover"]).pack(fill="x", padx=10, pady=(15,5))

        # Bot√£o Tela Cheia
        fs_icon = None
        try: fs_img = Image.open(os.path.join(icon_path, "fullscreen.png")).resize((30, 30), Image.Resampling.LANCZOS); fs_icon = ImageTk.PhotoImage(fs_img)
        except Exception: pass
        self.fullscreen_button = tk.Button(self.sidebar_frame, text="  Tela Cheia", image=fs_icon, compound="left", font=CONFIG["fonts"]["normal_bold"], bg=CONFIG["colors"]["sidebar_bg"], fg=CONFIG["colors"]["text_light"], relief="flat", anchor="w", command=self.toggle_fullscreen)
        self.fullscreen_button.image = fs_icon; self.fullscreen_button.pack(fill="x", pady=5, padx=10)
        self.fullscreen_button.bind("<Enter>", lambda e, b=self.fullscreen_button: b.config(bg=CONFIG["colors"]["button_hover"])); self.fullscreen_button.bind("<Leave>", lambda e, b=self.fullscreen_button: b.config(bg=CONFIG["colors"]["sidebar_bg"]))

        # Bot√£o Modo Apresenta√ß√£o
        pres_icon = None
        try: pres_img = Image.open(os.path.join(icon_path, "presentation.png")).resize((30, 30), Image.Resampling.LANCZOS); pres_icon = ImageTk.PhotoImage(pres_img)
        except Exception: pass
        self.presentation_button = tk.Button(self.sidebar_frame, text="  Modo Apresenta√ß√£o", image=pres_icon, compound="left", font=CONFIG["fonts"]["normal_bold"], bg=CONFIG["colors"]["sidebar_bg"], fg=CONFIG["colors"]["text_light"], relief="flat", anchor="w", command=self.toggle_presentation_mode)
        self.presentation_button.image = pres_icon; self.presentation_button.pack(fill="x", pady=5, padx=10)
        self.presentation_button.bind("<Enter>", lambda e, b=self.presentation_button: b.config(bg=CONFIG["colors"]["button_hover"])); self.presentation_button.bind("<Leave>", lambda e, b=self.presentation_button: b.config(bg=CONFIG["colors"]["sidebar_bg"]))

        # Bot√£o Email Teste
        test_email_icon = None
        try: test_img = Image.open(os.path.join(icon_path, "email_test.png")).resize((30, 30), Image.Resampling.LANCZOS); test_email_icon = ImageTk.PhotoImage(test_img)
        except Exception: pass
        self.test_email_button = tk.Button(self.sidebar_frame, text="  Enviar Email Teste", image=test_email_icon, compound="left", font=CONFIG["fonts"]["normal_bold"], bg=CONFIG["colors"]["sidebar_bg"], fg="#FFA500", relief="flat", anchor="w", command=self._run_threaded_report_task)
        self.test_email_button.image = test_email_icon; self.test_email_button.pack(fill="x", pady=5, padx=10)
        self.test_email_button.bind("<Enter>", lambda e, b=self.test_email_button: b.config(bg=CONFIG["colors"]["button_hover"])); self.test_email_button.bind("<Leave>", lambda e, b=self.test_email_button: b.config(bg=CONFIG["colors"]["sidebar_bg"]))

    # --- M√©todos de Controle de Tela e Modos ---
    def show_screen(self, screen_name, single_coord=None):
        """Mostra a tela especificada, escondendo a anterior."""
        if self.current_screen:
            self.current_screen.hide()
            current_name = self.get_current_screen_name()
            # S√≥ atualiza cor do bot√£o se n√£o estiver em modo apresenta√ß√£o e bot√£o existir
            if not self.is_presentation_mode and current_name in self.nav_buttons:
                self.nav_buttons[current_name].config(bg=CONFIG["colors"]["sidebar_bg"])

        self.current_screen = self.screens[screen_name]

        # Passa argumento extra para CoordinatorScreen
        if screen_name == "coordinators":
            self.current_screen.show(single_coord=single_coord)
        else:
            self.current_screen.show() # Chama show sem argumento extra

        # Destaca o bot√£o da tela atual, se aplic√°vel
        if not self.is_presentation_mode and screen_name in self.nav_buttons:
            self.nav_buttons[screen_name].config(bg=CONFIG["colors"]["content_bg"])

    def get_current_screen_name(self):
        """Retorna a chave (nome) da tela atualmente vis√≠vel."""
        for name, screen in self.screens.items():
            if screen == self.current_screen:
                return name
        return None

    def toggle_presentation_mode(self):
        """Ativa ou desativa o modo de apresenta√ß√£o (slideshow autom√°tico)."""
        self.is_presentation_mode = not self.is_presentation_mode
        if self.is_presentation_mode:
            # Esconde a barra lateral e inicia o ciclo
            self.sidebar_frame.pack_forget()
            self.slideshow_index = 0
            self.coordinator_slideshow_index = 0
            self.current_coordinator_list = []
            self._cycle_screens()
        else:
            # Para o ciclo e mostra a barra lateral
            if self.slideshow_job:
                self.root.after_cancel(self.slideshow_job)
                self.slideshow_job = None
            self.sidebar_frame.pack(side="left", fill="y")
            # Mostra a tela que deveria estar vis√≠vel (ou 'leader' como fallback)
            current_intended_screen = self.get_current_screen_name() or "leader"
            self.show_screen(current_intended_screen)

    def _cycle_screens(self):
        """Motor do slideshow: avan√ßa para a pr√≥xima tela ou pr√≥ximo coordenador."""
        if not self.is_presentation_mode: return # Para se saiu do modo

        current_screen_key = self.slideshow_order[self.slideshow_index]
        next_interval_ms = CONFIG["slideshow_interval_seconds"] * 1000

        if current_screen_key == "coordinators":
            if not self.current_coordinator_list: # Carrega lista na primeira vez
                rankings = self.data_handler.get_data().get('coordinator_rankings', {})
                self.current_coordinator_list = list(rankings.keys())
                self.coordinator_slideshow_index = 0

            if self.current_coordinator_list and self.coordinator_slideshow_index < len(self.current_coordinator_list):
                coord_name = self.current_coordinator_list[self.coordinator_slideshow_index]
                self.show_screen("coordinators", single_coord=coord_name)
                self.coordinator_slideshow_index += 1
                next_interval_ms = CONFIG["coordinator_slideshow_seconds"] * 1000 # Intervalo curto
                # N√£o avan√ßa self.slideshow_index ainda
            else: # Todos os coordenadores mostrados
                self.slideshow_index = (self.slideshow_index + 1) % len(self.slideshow_order)
                next_screen_key = self.slideshow_order[self.slideshow_index]
                self.show_screen(next_screen_key)
                self.current_coordinator_list = [] # Reseta para pr√≥ximo ciclo
                self.coordinator_slideshow_index = 0
        else: # Outras telas
            self.show_screen(current_screen_key)
            self.slideshow_index = (self.slideshow_index + 1) % len(self.slideshow_order)
            self.current_coordinator_list = [] # Reseta caso venha da tela de coordenadores
            self.coordinator_slideshow_index = 0

        self.slideshow_job = self.root.after(next_interval_ms, self._cycle_screens)

    # --- M√©todos de Screenshot e Email ---
    def _take_screenshot(self, target_widget, filename):
        """Tira screenshot do widget especificado (geralmente self.root) e salva."""
        screenshots_dir = CONFIG["file_paths"]["screenshots_folder"]
        if not os.path.exists(screenshots_dir): os.makedirs(screenshots_dir)
        filepath = os.path.abspath(os.path.join(screenshots_dir, filename))
        try:
            target_widget.update_idletasks() # Atualiza dimens√µes
            x = target_widget.winfo_rootx()
            y = target_widget.winfo_rooty()
            w = target_widget.winfo_width()
            h = target_widget.winfo_height()
            if w <= 1 or h <= 1: time.sleep(1); x,y,w,h = target_widget.winfo_rootx(), target_widget.winfo_rooty(), target_widget.winfo_width(), target_widget.winfo_height() # Tenta de novo
            if w > 1 and h > 1:
                print(f"Capturando √°rea: X={x}, Y={y}, W={w}, H={h} para {filename}")
                bbox = (x, y, x + w, y + h)
                im = ImageGrab.grab(bbox=bbox)
                im.save(filepath)
                print(f"Screenshot salvo: {filepath}")
                return filepath
            else: print(f"ERRO FATAL: Dimens√µes inv√°lidas para screenshot {filename}. W={w}, H={h}"); return None
        except Exception as e: print(f"ERRO ao tirar screenshot '{filename}': {e}"); return None

    def _send_outlook_email(self, recipient, subject, body, attachments=None):
        """Envia email via Outlook, incluindo assinatura padr√£o e aviso autom√°tico."""
        if attachments is None: attachments = []
        try:
            outlook = win32.Dispatch('outlook.application')
            mail = outlook.CreateItem(0); mail.To = recipient; mail.Subject = subject
            full_body = body + "\n\n---\n" + \
                        "Este √© um e-mail autom√°tico enviado pelo sistema de Dashboard de Performance." + \
                        CONFIG["email_settings"]["body_footer"]
            try: mail.HTMLBody = f"<html><body>{full_body.replace(chr(10), '<br>').replace(chr(13), '')}</body></html>"
            except Exception: mail.Body = full_body # Fallback
            for attachment_path in attachments:
                if attachment_path and os.path.exists(attachment_path): mail.Attachments.Add(attachment_path)
                else: print(f"Aviso: Anexo n√£o encontrado: {attachment_path}")
            mail.Send()
            print(f"Email enviado para: {recipient}"); return True
        except AttributeError as e_attr: print(f"ERRO Outlook: {e_attr}. Verifique se est√° aberto/configurado."); return False
        except Exception as e: print(f"ERRO GERAL ao enviar email para {recipient}: {e}"); return False

    def _send_daily_reports_task(self):
        """Tarefa agendada para emails: ajusta tela, tira screenshots, envia, restaura."""
        pythoncom.CoInitialize()
        try:
            print(f"\n[{datetime.now().strftime('%H:%M:%S')}] Iniciando envio de relat√≥rios di√°rios...")
            RENDER_DELAY_MS = 2500

            initial_fullscreen_state = self.is_fullscreen
            initial_presentation_state = self.is_presentation_mode

            # Entra no estado de captura (agendado na thread principal)
            event_set_mode = threading.Event()
            def task_set_mode():
                if not self.is_fullscreen: self.toggle_fullscreen()
                if not self.is_presentation_mode: self.toggle_presentation_mode()
                self.root.update(); event_set_mode.set()
            self.root.after(0, task_set_mode); event_set_mode.wait(timeout=5)
            print("Entrou em modo Tela Cheia/Apresenta√ß√£o para screenshots.")
            time.sleep(1.5)

            screenshots_dir = CONFIG["file_paths"]["screenshots_folder"]
            boss_attachments = []

            def take_screenshot_on_main_thread(screen_name, filename, single_coord=None):
                img_path = None; event_capture = threading.Event()
                def capture_task(): nonlocal img_path; img_path = self._take_screenshot(self.root, filename); event_capture.set()
                def show_and_schedule_capture():
                    self.show_screen(screen_name, single_coord=single_coord); self.root.update_idletasks(); self.root.update()
                    self.root.after(RENDER_DELAY_MS, capture_task)
                self.root.after(0, show_and_schedule_capture)
                if not event_capture.wait(timeout=RENDER_DELAY_MS + 5): print(f"ERRO: Timeout screenshot {screen_name}"); return None
                return img_path

            # Tira Screenshots
            print("Capturando tela do L√≠der..."); leader_img = take_screenshot_on_main_thread("leader", "leader_report.png");
            if leader_img: boss_attachments.append(leader_img)
            print("Capturando tela do Ranking..."); ranking_img = take_screenshot_on_main_thread("ranking", "ranking_report.png");
            if ranking_img: boss_attachments.append(ranking_img)

            # Envia para Chefe
            if boss_attachments: self._send_outlook_email(CONFIG["email_settings"]["boss_email"], CONFIG["email_settings"]["subject"], CONFIG["email_settings"]["body_header"] + "\n- Vis√£o Geral (L√≠der e Top 5)", boss_attachments)
            else: print("Nenhum screenshot geral gerado.")

            # Envia para Coordenadores
            rankings = self.data_handler.get_data().get('coordinator_rankings', {}); coordinator_emails = CONFIG["email_settings"]["coordinator_emails"]
            for coord_name in rankings:
                print(f"Capturando relat√≥rio para: {coord_name}")
                coord_img = take_screenshot_on_main_thread("coordinators", f"coord_{coord_name.replace(' ', '_')}.png", single_coord=coord_name)
                recipient = coordinator_emails.get(coord_name)
                if recipient and coord_img: self._send_outlook_email(recipient, CONFIG["email_settings"]["subject"] + f" - Equipe {coord_name}", CONFIG["email_settings"]["body_header"] + f"\n- Desempenho da sua equipe ({coord_name})", [coord_img])
                elif not recipient: print(f"Aviso: Email n√£o config para '{coord_name}'.")
                elif not coord_img: print(f"Aviso: Falha screenshot para '{coord_name}'.")

            # Limpeza
            try: [os.remove(os.path.join(screenshots_dir, f)) for f in os.listdir(screenshots_dir) if f.endswith(".png")]; print("Screenshots temp removidos.")
            except Exception as e: print(f"Aviso: N√£o remover screenshots: {e}")

        finally:
            # Restaura estado (agendado na thread principal)
            event_restore = threading.Event()
            def task_restore():
                print("Restaurando estado da janela...")
                if not initial_presentation_state and self.is_presentation_mode: self.toggle_presentation_mode()
                if not initial_fullscreen_state and self.is_fullscreen: self.toggle_fullscreen()
                self.root.update(); self.show_screen("leader"); print("Estado restaurado."); event_restore.set()
            self.root.after(50, task_restore); event_restore.wait(timeout=5)
            pythoncom.CoUninitialize()
            print(f"[{datetime.now().strftime('%H:%M:%S')}] Envio de relat√≥rios di√°rios conclu√≠do.")

    # --- M√©todos de Agendamento e Loop Principal ---
    def _run_threaded_report_task(self):
        """Inicia a tarefa de envio de email em uma nova thread."""
        report_thread = threading.Thread(target=self._send_daily_reports_task)
        report_thread.start()

    def _check_schedule(self):
        """Verifica o agendador a cada minuto."""
        schedule.run_pending()
        self.root.after(60000, self._check_schedule)

    def _setup_scheduler(self):
        """Configura o agendamento de envio de emails."""
        send_time = CONFIG["email_settings"]["send_time"]
        print(f"Agendando envio de emails para as {send_time} (Seg-Sex).")
        schedule.every().monday.at(send_time).do(self._run_threaded_report_task)
        schedule.every().tuesday.at(send_time).do(self._run_threaded_report_task)
        schedule.every().wednesday.at(send_time).do(self._run_threaded_report_task)
        schedule.every().thursday.at(send_time).do(self._run_threaded_report_task)
        schedule.every().friday.at(send_time).do(self._run_threaded_report_task)
        self._check_schedule() # Inicia a verifica√ß√£o

    def periodic_update(self):
        """Verifica atualiza√ß√µes na planilha e atualiza a UI."""
        if self.data_handler.update_flag:
            if self.data_handler.load_and_process_data():
                print("Dados atualizados. Atualizando UI.")
                if self.current_screen:
                     # Passa o argumento 'single_coord' se a tela atual for a de coordenadores no modo apresenta√ß√£o
                     current_coord = None
                     if isinstance(self.current_screen, CoordinatorScreen) and self.is_presentation_mode:
                          if self.current_coordinator_list and self.coordinator_slideshow_index > 0:
                               current_coord = self.current_coordinator_list[self.coordinator_slideshow_index - 1] # Pega o que acabou de ser exibido
                     self.current_screen.update_content(single_coord=current_coord)

        self.root.after(CONFIG["update_interval_ms"], self.periodic_update)

    def run(self):
        """Inicia o loop principal da aplica√ß√£o Tkinter."""
        try:
            self.root.mainloop()
        finally:
            # Garante que o watcher seja parado ao fechar
            self.file_watcher.stop()
            self.file_watcher.join()
            print("Monitoramento de arquivo finalizado.")
            # Cancela agendamentos pendentes
            schedule.clear()
            
    def periodic_update(self):
        if self.data_handler.update_flag:
            if self.data_handler.load_and_process_data():
                print("Dados atualizados. Atualizando UI.")
                if self.current_screen: self.current_screen.update_content()
        self.root.after(CONFIG["update_interval_ms"], self.periodic_update)
    
    def run(self):
        try:
            self.root.mainloop()
        finally:
            self.file_watcher.stop()
            self.file_watcher.join()

# =============================================================================
# 5. PONTO DE ENTRADA DO PROGRAMA
# =============================================================================
if __name__ == "__main__":
    # Cria a pasta de screenshots tempor√°rios se n√£o existir
    screenshots_dir = CONFIG["file_paths"]["screenshots_folder"]
    if not os.path.exists(screenshots_dir):
        os.makedirs(screenshots_dir)
        
    root = tk.Tk()
    app = DashboardApp(root)
    app.run()

# =============================================================================
# Fim ? N√£o h√° mais nada al√©m disso. mas quem sabe no futuro... 
# Projeto: Dashboard de Performance RODOLUB v2.0 Animated
# Horas Gastas nesse c√≥digo: 18 horas
# Autor: Theflerres - Github.com/theflerres 
# Nome dentro da empresa Rodolub: Jo√£o Victor Galv√£o Alves.
# Data de inicio do projeto: 16 de Outubro de 2024 
# 1k de linhas de c√≥digo...(pausa pro caf√©zinho)
# =============================================================================

